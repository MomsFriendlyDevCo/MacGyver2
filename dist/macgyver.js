/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("lodash"));
	else if(typeof define === 'function' && define.amd)
		define(["lodash"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("lodash")) : factory(root["_"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, (__WEBPACK_EXTERNAL_MODULE_lodash__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/entrypoint-node.js":
/*!********************************!*\
  !*** ./src/entrypoint-node.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MacGyver\": () => (/* reexport safe */ _macgyver_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _macgyver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./macgyver.js */ \"./src/macgyver.js\");\n\n\n//# sourceURL=webpack://@momsfriendlydevco/macgyver/./src/entrypoint-node.js?");

/***/ }),

/***/ "./src/macgyver.js":
/*!*************************!*\
  !*** ./src/macgyver.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ \"lodash\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var sift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sift */ \"./node_modules/sift/es5m/index.js\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nvar _this2 = undefined;\n\nfunction _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, void 0, groups); }; var _super = RegExp.prototype, _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype); } function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { return groups[name] = result[g[name]], groups; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); return result && (result.groups = buildGroups(result, this)), result; }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (\"string\" == typeof substitution) { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) { return \"$\" + groups[name]; })); } if (\"function\" == typeof substitution) { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; return \"object\" != _typeof(args[args.length - 1]) && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args); }); } return _super[Symbol.replace].call(this, str, substitution); }, _wrapRegExp.apply(this, arguments); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n* Shared front-end / back-end MacGyver utilities\n* For Vue specific utilities see ./macgyver.vue\n*/\n\n\nvar $macgyver = {};\n/**\n* Storage for all MacGyver registered widgets\n* Each key is the unique reference name of the component e.g. `\"mgText\"`\n* Each value is the original options object definition passed to `Vue.mgCompoenent(name, options)`\n* @var {Object}\n*/\n\n$macgyver.widgets = {};\n$macgyver.$nextId = 0;\n\n$macgyver.nextId = function () {\n  return \"mgForm\".concat($macgyver.$nextId++);\n};\n/**\n* Set of convenience functions to manage on-screen MacGyver forms\n*/\n\n\n$macgyver.forms = {};\n/**\n* Set the given forms spec config\n* @param {string} id The ID of the form to set the config of\n* @param {Object|Array} config The config to set\n* @returns {MacGyver} The chainable MacGyver instance\n*/\n\n$macgyver.forms.setConfig = function (id, config) {\n  if (!$macgyver.$forms[id]) $macgyver.$forms[id] = {\n    config: {},\n    data: {}\n  };\n  $macgyver.$forms[id].config = $macgyver.compileSpec(config).spec;\n  return $macgyver;\n};\n/**\n* Set the given forms spec data\n* @param {string} id The ID of the form to set the config of\n* @param {Object|Array} data The data population to set\n* @returns {MacGyver} The chainable MacGyver instance\n*/\n\n\n$macgyver.forms.setData = function (id, data) {\n  if (!$macgyver.$forms[id]) $macgyver.$forms[id] = {\n    config: {},\n    data: {}\n  };\n  $macgyver.$forms[id].data = data;\n  return $macgyver;\n};\n/**\n* Convenience function to validate all MacGyver forms on a screen and return the array of failed validations\n* @param {string} [id] The form ID to validate, if omitted the first form on the page is used\n* @param {boolean} [showErrors=true] Allow the form to display a list of errors as well as returning them\n* @returns {array <Object>} Collection where each item is {error}\n*/\n\n\n$macgyver.forms.validate = function (id) {\n  var showErrors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (!$macgyver.$forms[id]) throw new Error('Invalid MacGyver form');\n  console.warn('FIXME: Validation not yet supported');\n  var responses = []; // FIXME: This needs to work internally using flatten()\n\n  return true;\n};\n/**\n* Emit a message to a specific mgForm element\n* @param {string} id The ID of the form to emit to\n* @param {string} msg The message to emit\n* @param {*} [payload...] The payload of the message to emit\n*/\n\n\n$macgyver.forms.emit = function (id, msg) {\n  var _$macgyver$$forms$id;\n\n  if (!$macgyver.$forms[id]) throw new Error('Unknown form ID');\n\n  for (var _len = arguments.length, payload = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    payload[_key - 2] = arguments[_key];\n  }\n\n  (_$macgyver$$forms$id = $macgyver.$forms[id]).$emit.apply(_$macgyver$$forms$id, [msg].concat(payload));\n};\n/**\n* Emit a message to all child controls of a given form\n* @param {string} id The ID of the form to emit to\n* @param {string} msg The message to emit\n* @param {*} [payload...] The payload of the message to emit\n*/\n\n\n$macgyver.forms.emitDown = function (id, msg) {\n  var _$macgyver$$forms$id2;\n\n  if (!$macgyver.$forms[id]) throw new Error('Unknown form ID');\n\n  for (var _len2 = arguments.length, payload = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    payload[_key2 - 2] = arguments[_key2];\n  }\n\n  (_$macgyver$$forms$id2 = $macgyver.$forms[id]).$emitDown.apply(_$macgyver$$forms$id2, [msg].concat(payload));\n};\n\n$macgyver.forms.getPath = function (id, path, fallback) {\n  return $macgyver.utils.getPath($macgyver.$forms[id], path, fallback);\n};\n/**\n* Compute the data prototype of the form\n* This is an empty object with all the defaults populated\n* @param {Object} spec The form spec object to exmaine\n* @returns {Object} A prototype data object with all defaults populated\n*/\n\n\n$macgyver.forms.getPrototype = function (spec) {\n  return $macgyver.flatten(spec, {\n    type: 'spec',\n    want: 'array',\n    wantDataPath: true\n  }).reduce(function (data, node) {\n    if (!node.path || !node.default) return data; // No path or default speciifed - skip\n\n    $macgyver.utils.setPath(data, node.path, node.default);\n    return data;\n  }, {});\n}; // $macgyver.notify{} {{{\n\n/**\n* A collection of ways MacGyver can notify the user\n* These should be replaced by whatever your local framework supports\n*/\n\n\n$macgyver.notify = {};\n/**\n* Signify that a loading event is taking place\n* This function should be overridden by the framework to include whatever load handling is requried\n* By default it uses https://www.npmjs.com/package/@momsfriendlydevco/loader\n* @param {string} id The unique ID for the loading item\n* @param {boolean} [status=true] Whether the item is performing an operation that requires loading\n* @param {Object} [options] Additional options\n* @param {boolean} [options.foreground=false] Whether the loading event should occur in the foreground\n*/\n\n$macgyver.notify.loading = function (id) {\n  var status = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (status && options && options.foreground) {\n    console.log('[$macgyver]', 'Loading foreground', id, {\n      status: status\n    });\n  } else if (status) {\n    console.log('[$macgyver]', 'Loading background', id, {\n      status: status\n    });\n  } else {\n    console.log('[$macgyver]', 'Stop loading', id, {\n      status: status\n    });\n  }\n};\n/**\n* Provide a warning message to the user\n* @param {string} message The message to display\n*/\n\n\n$macgyver.notify.warn = function (message) {\n  return console.log('[$macgyver]', 'WARN', message);\n};\n/**\n* Provide an error message to the user\n* @param {string} message The message to display\n*/\n\n\n$macgyver.notify.error = function (message) {\n  return console.log('[$macgyver]', message);\n}; // }}}\n\n/**\n* Flatten the a spec into an object lookup where each key is the dotted notation of the key\n* NOTE: Specifying {want:'array'} will add the extra property 'path' onto the output collection\n* @param {Object|array} root The data or spec object to examine, this should be the root object but can also convert arrays into objects on the fly (although this is slower)\n* @param {Object} [options] Optional settings to use\n* @param {number} [options.maxDepth=0] How far down the tree to recurse, set to falsy to infinitely recurse\n* @param {Object|function} [options.filter] Either a Lodash match expression or a function to run on each widget - only truthy values are appended to the output. Function is called as `(widget, dataPath, specPath, depth)`\n* @param {Object|function} [options.filterChildren] Either a Lodash match expression or a function to run on each widget - only truthy values are recursed into. Function is called as `(widget, dataPath, specPath, depth)`\n* @param {string} [type=\"auto\"] How to recurse into items. ENUM: 'auto' (try to determine how to recurse from root element), 'spec', 'data'\n* @param {string} [want=\"object\"] How to return the output. ENUM: 'object' (an object where each key is the path and the value is the object), 'array' (a flattened version of an object), object is faster\n* @param {boolean|string} [wantDataPath=false] Whether to mutate the output widget with a dotted notation string indicating where to look in a data object for the value of the widget, if this is a string it specifies the key to use as storage\n* @param {boolean} [wantSpec=false] Whether to mutate the output widget with the widget specification as an object for each item\n* @param {boolean|string} [wantSpecPath=false] Whether to mutate the output widget with a dotted notation path on where to find the widget within a spec object, if this is a string it specifies the key to use as storage\n*/\n\n\n$macgyver.flatten = function (root, options) {\n  var settings = lodash__WEBPACK_IMPORTED_MODULE_0___default().defaults(options, {\n    root: lodash__WEBPACK_IMPORTED_MODULE_0___default().isArray(root) ? $macgyver.compileSpec(root).spec : root,\n    maxDepth: 0,\n    filter: undefined,\n    filterChildren: undefined,\n    type: 'auto',\n    want: 'object',\n    wantDataPath: false,\n    wantSpec: false,\n    wantSpecPath: false\n  });\n\n  if (settings.filter && !lodash__WEBPACK_IMPORTED_MODULE_0___default().isFunction(settings.filter) && lodash__WEBPACK_IMPORTED_MODULE_0___default().isObject(settings.filter)) settings.filter = lodash__WEBPACK_IMPORTED_MODULE_0___default().matches(settings.filter);\n  if (settings.want != 'object' && settings.want != 'array') throw new Error('$macgyver.flatten({want}) can only be \"object\" or \"array\"');\n\n  if (settings.type == 'auto') {\n    if (settings.root && settings.root.items) {\n      settings.type = 'spec';\n    } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default().every(settings.root, function (k, v) {\n      return !v.items;\n    })) {\n      settings.type = 'data';\n    } else {\n      throw new Error('Cannot determine type of input object to $macgyver.flatten(), specify it explicitly with {type=spec|data}');\n    }\n  }\n\n  var found = settings.want == 'object' ? {} : [];\n\n  var depthScanner = function depthScanner(node, dataPath, specPath, depth) {\n    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default().isObject(node)) return; // Add to bucket of found objects?\n\n    if (!settings.filter // No filter\n    || settings.filter.call(node, node, path, depth) // OR we pass the filter\n    ) {\n      if (settings.wantDataPath) node[lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(settings.wantDataPath) ? settings.wantDataPath : 'path'] = dataPath.concat([node.id]).filter(function (i) {\n        return i;\n      }).join('.');\n      if (settings.wantSpecPath) node[lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(settings.wantSpecPath) ? settings.wantSpecPath : 'specPath'] = specPath.join('.');\n\n      if (settings.want == 'object') {\n        if (node.id) found[node.id] = node;\n      } else {\n        found.push(node);\n      }\n    } // Recurse into children?\n\n\n    var recursionSubject = settings.type == 'spec' ? node.items : node;\n\n    if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isArray(recursionSubject) && (!settings.filterChildren // No filter\n    || settings.filterChildren.call(node, node, dataPath, specPath, depth) // ...or we pass the filter\n    ) && (!settings.maxDepth || depth <= settings.maxDepth)) {\n      recursionSubject.forEach(function (item, itemIndex) {\n        return depthScanner(item, dataPath, specPath.concat(settings.type == 'spec' ? ['items', itemIndex] : [itemIndex]), depth + 1);\n      });\n    }\n  };\n\n  depthScanner(settings.root, [], [], 0);\n  return found;\n};\n/**\n* Apply various criteria to a 'rough' spec to turn it into a clean one\n*\n* NOTE: 'Shorthand' is a simple `{id1: spec1, id2: spec2}` way of setting up a form. See the widget config for an example\n*       Shorthand may also have types that omit the `mg` prefix e.g. `text` instead of `mgText`\n*\n* @param {Object|array} spec A MacGyver spec to process and mutate\n* @param {Object} [options] Additional options to use\n* @param {boolean} [options.clone=true] Whether to clone the object before neatening, slow but Vue disallows mutation\n* @param {boolean} [options.convertArray=true] Convert arrays to object if not already in that format\n* @param {function} [options.convertArrayWrapper] Function used to convert from array - defaults to a simple mgContainer wrapper. Called as (spec)\n* @param {boolean} [options.convertShorthand=true] Accept shorthand format and convert if necessary\n* @param {function} [options.convertShorthandDetect] Function used to detect shorthand format - defaults to object with valid string keys sans 'id' field. Called as (spec)\n* @param {function} [options.convertShorthandTranslate] Function used to convert shorthand format. Called as (spec)\n* @param {boolean} [options.widgetDefaults=true] Assign each item its default values from the widget config if that setting is omitted\n* @param {string} [options.widgetTitles=true] Add any missing title fields from the ID\n* @param {boolean} [options.deblank=true] Reformat null/undefined/empty forms into a skeleton form\n* @returns {Object} An object composed of the keys {spec}\n*/\n\n\n$macgyver.compileSpec = function (spec, options) {\n  var settings = _objectSpread({\n    clone: true,\n    convertArray: true,\n    convertArrayWrapper: function convertArrayWrapper(items) {\n      return {\n        type: 'mgContainer',\n        showTitles: false,\n        items: items\n      };\n    },\n    convertShorthand: true,\n    convertShorthandDetect: function convertShorthandDetect(spec) {\n      return lodash__WEBPACK_IMPORTED_MODULE_0___default().isPlainObject(spec) // Simple object\n      && !lodash__WEBPACK_IMPORTED_MODULE_0___default().has(spec, 'type') // It doesn't have a type key (i.e. there is only one item in this object\n      && lodash__WEBPACK_IMPORTED_MODULE_0___default().every(spec, function (v, k) {\n        return !lodash__WEBPACK_IMPORTED_MODULE_0___default().has(v, 'id') && (!lodash__WEBPACK_IMPORTED_MODULE_0___default().has(v, 'type') || v.type != 'mgContainer');\n      });\n    },\n    // Each item lacks an ID and either doesn't have a type or that type is not a container\n    convertShorthandTranslate: function convertShorthandTranslate(spec) {\n      return {\n        type: 'mgContainer',\n        items: lodash__WEBPACK_IMPORTED_MODULE_0___default().map(spec, function (widget, id) {\n          var _widget$type;\n\n          if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(widget)) widget = {\n            type: widget\n          }; // Widget is a straight string (e.g. 'boolean'), then fall through to type finders\n\n          if ((_widget$type = widget.type) !== null && _widget$type !== void 0 && _widget$type.startsWith('mg')) {\n            // Already a defined MacGyver spec\n            return widget;\n          } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(id) && id.startsWith('mg')) {\n            // ID is type, payload is widget\n            return _objectSpread(_objectSpread({}, widget), {}, {\n              type: id\n            });\n          } else if (widget.type) {\n            // We have a type - try to match it against known widgets (or error out)\n            var typeLCase = widget.type.toLowerCase();\n\n            var found = lodash__WEBPACK_IMPORTED_MODULE_0___default().find($macgyver.widgets, function (mgWidget) {\n              return (// Search for likely widgets\n                mgWidget.meta.id.substr(2).toLowerCase() == typeLCase // matches `mg${TYPE}`\n                || mgWidget.meta.shorthand.includes(typeLCase)\n              );\n            } // is included in shorthand alternatives\n            );\n\n            if (found) {\n              // Found either a widget of form `mg${type}` or a widget with that type as a shorthand\n              return _objectSpread(_objectSpread({\n                id: id\n              }, widget), {}, {\n                type: found.meta.id\n              });\n            } else {\n              // No idea what this widget is, wrap in an mgError\n              return {\n                type: 'mgError',\n                text: \"Unknown widget type \\\"\".concat(widget.type, \"\\\": \") + JSON.stringify(widget, null, '\\t')\n              };\n            }\n          } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isPlainObject(widget)) {\n            // Given object but it explicitly does not have a type - assume mgText\n            return _objectSpread(_objectSpread({\n              id: id\n            }, widget), {}, {\n              type: 'mgText'\n            });\n          } else {\n            // Can't determine any type to link against - error out\n            return {\n              type: 'mgError',\n              text: \"No widget type specified: \" + JSON.stringify(widget, null, '\\t')\n            };\n          }\n        })\n      };\n    },\n    widgetDefaults: true,\n    widgetTitles: true,\n    deblank: true\n  }, options);\n\n  var spec = settings.clone ? lodash__WEBPACK_IMPORTED_MODULE_0___default().cloneDeep(spec) : spec; // Output spec\n\n  if (settings.deblank && lodash__WEBPACK_IMPORTED_MODULE_0___default().isEmpty(spec)) {\n    // Convert empty or unusable values into a skeleton\n    spec = {\n      type: 'mgContainer',\n      items: []\n    };\n  }\n\n  if (settings.convertArray && lodash__WEBPACK_IMPORTED_MODULE_0___default().isArray(spec)) {\n    // convert array spec -> object?\n    spec = settings.convertArrayWrapper(spec);\n  }\n\n  if (settings.convertShorthand && settings.convertShorthandDetect(spec)) {\n    // Is shorthand format\n    spec = settings.convertShorthandTranslate(spec);\n  }\n  /**\n  * Collection of items that have a showIf property\n  * @var {array<Object>} Each widget with a showIf property\n  */\n\n\n  var showIfs = [];\n  $macgyver.flatten(spec, {\n    type: 'spec',\n    want: 'array',\n    wantDataPath: '$dataPath',\n    wantSpecPath: '$specPath'\n  }).forEach(function (widget) {\n    if (!widget.type || !$macgyver.widgets[widget.type]) {\n      // Remap unknown widget (we already did shorthand remapping above so this should be a 1:1 match)\n      console.log(\"Unknown widget '\".concat(widget.type, \"'\"), widget);\n      widget = {\n        type: 'mgError',\n        text: \"Unknown widget type \\\"\".concat(widget.type, \"\\\": \") + JSON.stringify(widget)\n      };\n    } else if (settings.widgetDefaults) {\n      // Apply defaults to widget\n      Object.assign(widget, lodash__WEBPACK_IMPORTED_MODULE_0___default().chain($macgyver.widgets[widget.type].config).pickBy(function (v, k) {\n        return !lodash__WEBPACK_IMPORTED_MODULE_0___default().has(widget, k) && lodash__WEBPACK_IMPORTED_MODULE_0___default().has(v, 'default');\n      }).mapValues(function (v) {\n        return v.default;\n      }).value());\n    } // Glue .show property to all elements that omit it\n\n\n    widget.show = widget.show == undefined ? true : !!widget.show; // Add all widgets with a .showIf expression into a quick-lookup collection\n\n    if (widget.showIf) {\n      widget.showIf = $macgyver.utils.evalCompile(widget.showIf); // Compile showIf property so its as fast as possible\n\n      showIfs.push(widget);\n    }\n\n    if (settings.widgetTitles && !widget.title && widget.id) widget.title = lodash__WEBPACK_IMPORTED_MODULE_0___default().startCase(widget.id);\n  });\n  return {\n    spec: spec,\n    showIfs: showIfs\n  };\n};\n/**\n* Register of known forms to their Vue instance / plain object mapping\n* For front-end MacGyver this is the VueInstance object of the registered form\n* For the back-end this is a simple object of the form `{config, data}`\n* @var {VueInstance|Object>}\n* @property {Object} config The form spec\n* @property {Object} data The current form data\n*/\n\n\n$macgyver.$forms = {};\n/**\n* Set of misc utility helper functions\n* @var {Object};\n*/\n\n$macgyver.utils = {};\n/**\n* Local storage for the global object\n* This is a wrapper until `globalThis` becomes available in both Node and the browser\n* @var {Object} The global scope\n*/\n\n$macgyver.utils.global = function () {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n\n  if (typeof __webpack_require__.g !== 'undefined') {\n    return __webpack_require__.g;\n  }\n\n  throw new Error('unable to locate global object');\n}();\n/**\n* Fetch any artbitrary data set from a URL\n* This function is designed to accept a customizable single-string URL which the user can customize and a spec options object that the requesting widget can define\n* NOTE: This function will invoke the loading notifier and call the warning notifier on an error\n*\n* @param {string} [url] The URL to fetch\n* @param {Object} options Additional options\n* @param {string} [options.url] Alternate way to pass the URL\n* @param {boolean} [options.type='object'] What data type to expect from the server. ENUM: 'object', 'array', 'raw'. If array and mappings are specified each member of the collection is mapped and an array returned\n* @param {function} [options.format] Data formatter, defaults to a simple passthrough. Called as `(output, session)`\n* @param {string|function} [options.formatError] Error thrown if the formatter fails, can be a string or function called as `(err)`. Defaults to 'Unable to format data feed from ${url} - ${err.toString()}`\n* @param {string} [options.from] The field from where to retrieve the value\n*\n* @param {Object <Object>} [options.mappings={}] Mappings to extract, each key is the mapping name with the value as an object containing the below spec\n* @param {boolean} [options.mappings.required=false] Whether the mapping is required\n*\n* @returns {Object} The extracted data object\n*\n* @example Fetch a simple collection\n* fetch('/api/datafeeds/random/users')\n*\n* @example Generate a random number as an object and return the extracted value as the promise response\n* fetch('/api/datafeeds/random/number?$extract=number', {mappings: {extract: {required: true}, format: d => d.extract}});\n*\n* @example Fetch a collection of items extracting both 'id' and 'title' fields\n* fetch('/api/datafeeds/random/users?$title=name&$id=_id', {mappings: {_id: {required: true}, title: {required: true}}})\n*/\n\n\n$macgyver.utils.fetch = function (url, options) {\n  return Promise.resolve() // Sanity checks {{{\n  .then(function () {\n    return $macgyver.$http || Promise.reject('No Axios compatible HTTP library - set $macgyver.$http to the library reference');\n  }) // }}}\n  // Injection options from URL {{{\n  .then(function () {\n    if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isPlainObject(url)) {\n      var _ref = [url.url, url];\n      url = _ref[0];\n      options = _ref[1];\n    } else {\n      options.url = url;\n    }\n\n    if (!url) throw new Error('Unknown URL to fetch');\n  }) // }}}\n  // Create the initial session {{{\n  .then(function () {\n    return {\n      mappings: {},\n      // Parsed mappings (either a copy of settings.mappings || extracted from the URL)\n      parsedUrl: new URL(url, window.location),\n      settings: _objectSpread({\n        type: 'object',\n        mappings: {},\n        // Optional mappings the user provided\n        format: function format(data, session) {\n          return data;\n        },\n        formatError: function formatError(err) {\n          return \"Unable to format data feed from \".concat(url, \" - \").concat(err.toString());\n        }\n      }, options)\n    };\n  }) // }}}\n  // Extract mappings from the URL string {{{\n  .then(function (session) {\n    if (!lodash__WEBPACK_IMPORTED_MODULE_0___default().isEmpty(options.mappings)) {\n      // Mappings are specified in options\n      session.mappings = options.mappings;\n    } else {\n      // Try to extract mappings if options doesn't already have a parsed set\n      Array.from(session.parsedUrl.searchParams.entries()).forEach(function (pair) {\n        var _pair = _slicedToArray(pair, 2),\n            k = _pair[0],\n            v = _pair[1];\n\n        if (k.startsWith('$')) {\n          session.mappings[k.substr(1)] = {\n            required: false,\n            from: v\n          };\n          session.parsedUrl.searchParams.delete(k);\n        }\n      });\n    }\n\n    return session;\n  }) // }}}\n  // Make the request {{{\n  .then(function (session) {\n    return $macgyver.$http.get(session.parsedUrl.toString()).then(function (res) {\n      return session.response = res;\n    }).then(function () {\n      return session;\n    });\n  }) // }}}\n  // Apply object cohersion + mappings {{{\n  .then(function (session) {\n    switch (session.settings.type) {\n      case 'array':\n        if (!lodash__WEBPACK_IMPORTED_MODULE_0___default().isArray(session.response.data)) throw \"Expected an array from data feed \\\"\".concat(url, \"\\\" but got a non-array\");\n\n        if (!lodash__WEBPACK_IMPORTED_MODULE_0___default().isEmpty(session.mappings)) {\n          session.output = session.response.data.map(function (item, itemIndex) {\n            return lodash__WEBPACK_IMPORTED_MODULE_0___default().mapValues(session.mappings, function (v, k) {\n              if (v.required && item[v.from] === undefined) throw new Error(\"Required field \".concat(v.from, \" is not present in data feed for item #\").concat(itemIndex + 1));\n              return item[v.from];\n            });\n          });\n        } else {\n          session.output = session.response.data;\n        }\n\n        return session;\n\n      case 'object':\n        if (!lodash__WEBPACK_IMPORTED_MODULE_0___default().isPlainObject(session.response.data)) throw \"Expected object return from data feed \\\"\".concat(url, \"\\\" but got a non-plain-object\");\n\n        if (!lodash__WEBPACK_IMPORTED_MODULE_0___default().isEmpty(session.mappings)) {\n          session.output = lodash__WEBPACK_IMPORTED_MODULE_0___default().mapValues(session.mappings, function (v, k) {\n            if (v.required && session.response.data[k] === undefined) throw new Error(\"Required field \".concat(k, \" is not present in data feed for item #\").concat(itemIndex + 1));\n            return session.response.data[v.from];\n          });\n        } else {\n          session.output = session.response.data;\n        }\n\n        return session;\n\n      case 'raw':\n        session.output = session.response.data;\n        return session;\n    }\n  }) // }}}\n  // Apply formatter {{{\n  .then(function (session) {\n    try {\n      return session.settings.format(session.output, session);\n    } catch (err) {\n      throw lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(session.settings.formatError) ? session.settings.formatError : session.settings.formatError(err);\n    }\n  }) // }}}\n  .catch(function (err) {\n    $macgyver.notify.error(err);\n    throw err;\n  }).finally(function () {\n    return $macgyver.notify.loading(url, false);\n  });\n};\n/**\n* Attempt to parse a rough JS expression into a Sift / Mongo compatible expression\n* This makes future calls to $macgyver.utils.evalMatch() much quicker\n* TODO: This probably needs replacing / merging with [sift-shorthand](https://github.com/hash-bang/sift-shorthand) at some point\n* @param {Object|string} expression Input expression, if this is an object it is assumed to already be a sift expression and returned uneffected\n* @param {boolean} [asFunc=true] Return a Sift filtering function (the most efficient method), if falsy return the compiled object (useful for debugging)\n* @returns {Sift} Sift function for use with $macgyver.utils.evalMatch()\n*/\n\n\n$macgyver.utils.evalCompile = function (expression) {\n  var asFunc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var match;\n\n  if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isFunction(expression)) {\n    // Already compiled Sift function\n    if (!asFunc) throw new Error('Cannot convert compiled Sift object back to an object - disable asFunc parameter');\n    return expression;\n  } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isPlainObject(expression)) {\n    // An object but not as Sift function\n    return asFunc ? (0,sift__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(expression) : expression;\n  } else if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(expression) && (match = /*#__PURE__*/_wrapRegExp(/^\\s*([\\w\\d\\.]+)(\\s*==?\\s*|\\s*!=\\s*|\\s*<=?\\s*|\\s*>=?\\s*|\\s+\\$lte?\\s+|\\s+\\$gte?\\s+)(.+)\\s*$/, {\n    left: 1,\n    operand: 2,\n    right: 3\n  }).exec(expression))) {\n    // Simple direct (in)equality e.g. `a == 1', `b != 'this'`\n    match.groups.operand = match.groups.operand.trim();\n\n    if (isFinite(match.groups.right)) {\n      match.groups.right = +match.groups.right;\n    } else if (/^([\"']).*\\1$/.test(match.groups.right)) {\n      // Enclosed in \" or '\n      match.groups.right = match.groups.right.substr(1, match.groups.right.length - 2);\n    } // Convert string to boolean\n\n\n    if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(match.groups.right) && match.groups.right.toLowerCase() === 'true') match.groups.right = true;\n    if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(match.groups.right) && match.groups.right.toLowerCase() === 'false') match.groups.right = false;\n    var obj;\n\n    if (['=', '==', '$eq'].includes(match.groups.operand)) {\n      // Direct equality\n      obj = _defineProperty({}, match.groups.left, match.groups.right);\n    } else {\n      var siftOperand = ['!=', '$ne'].includes(match.groups.operand) ? '$ne' : ['>', '$gt'].includes(match.groups.operand) ? '$gt' : ['<', '$lt'].includes(match.groups.operand) ? '$lt' : ['>=', '$gte'].includes(match.groups.operand) ? '$gte' : ['<=', '$lte'].includes(match.groups.operand) ? '$lte' : function () {\n        throw new Error(\"Unknown operand \\\"\".concat(match.groups.operand, \"\\\" while parsing expression \\\"\").concat(expression, \"\\\"\"));\n      }();\n      obj = _defineProperty({}, match.groups.left, _defineProperty({}, siftOperand, match.groups.right));\n    }\n\n    return asFunc ? (0,sift__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(obj) : obj;\n  } else {\n    throw new Error(\"Error parsinng expression \\\"\".concat(expression, \"\\\", $macgyver.utils.evalCompile() can only process simple expressions for now, use Sift object syntax for more complex tests\"));\n  }\n};\n/**\n* Evaluate an expression and return if it matches the given environment\n* This function is used by the `showIf` parameter to determine field visibility\n* NOTE: Passing a string to this function is possible but its better to precompile the expression via $macgyver.utils.evalCompile() first so its quicker to process each time\n* @param {string|Object|Sift} expression String expression (which will be parsed), object (which will be parsed) or Sift object to filter by in asending order of efficiency\n* @param {Object} env Local environment to compare\n*/\n\n\n$macgyver.utils.evalMatch = function (expression, env) {\n  return [env].filter($macgyver.utils.evalCompile(expression)).length == 1;\n};\n/**\n* Set a dotted notation or array path to a set value\n* This function will correctly populate any missing entities, calling vm.$set on each traversal of the path\n* Passing undefined as a value removes the key (unless removeUndefined is set to false)\n* *\n* @param {Object} [target] The target to set the path of, if omitted the `vm` object is used as the base for traversal\n* @param {string|array} path The path to set within the target / vm\n* @param {*} value The value to set\n* @param {Object} [options] Additional options\n* @param {boolean} [options.arrayNumeric=true] Process numeric path segments as arrays\n* @param {boolean} [options.removeUndefined=true] If undefined is specified as a value the key is removed instead of being set\n* @param {boolean} [options.debug=false] Also print out debugging information when setting the value\n* @returns {Object} The set value, like $set()\n*\n* @example Set a deeply nested path within a target object\n* $macgyver.utils.setPath(this, 'foo.bar.baz', 123); // this.$data.foo.bar.baz = 123\n*\n* @example Set a deeply nested path, with arrays, assuming VM as the root node\n* $macgyver.utils.setPath('foo.1.bar', 123); // vm.$data.foo = [{bar: 123}]\n*/\n// FIXME: Duplication. Both this and \"vue-setpath\" should depend on a parent \"setpath\" package.\n\n\n$macgyver.utils.setPath = function (target, path, value, options) {\n  // Argument mangling {{{\n  if (lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(target) || lodash__WEBPACK_IMPORTED_MODULE_0___default().isArray(target)) {\n    // called as (path, value)\n    var _ref2 = [_this2, target, path, value];\n    target = _ref2[0];\n    path = _ref2[1];\n    value = _ref2[2];\n    options = _ref2[3];\n  } else if (!lodash__WEBPACK_IMPORTED_MODULE_0___default().isObject(target)) {\n    throw new Error('Cannot use $setPath on non-object target');\n  } // }}}\n\n\n  var settings = _objectSpread({\n    arrayNumeric: true,\n    debug: false,\n    removeUndefined: true\n  }, options);\n\n  if (settings.debug) console.debug('[$setPath]', path, '=', value, {\n    target: target,\n    options: options\n  });\n  var node = target;\n  if (!path) throw new Error('Cannot $setPath with undefined path');\n  (lodash__WEBPACK_IMPORTED_MODULE_0___default().isString(path) ? path.split('.') : path).some(function (chunk, chunkIndex, chunks) {\n    if (chunkIndex == chunks.length - 1) {\n      // Leaf node\n      if (settings.removeUndefined && value === undefined) {\n        $macgyver.utils.unset(node, chunk);\n      } else {\n        $macgyver.utils.set(node, chunk, value);\n      }\n    } else if (node[chunk] === undefined) {\n      // This chunk (and all following chunks) does't exist - populate from here\n      chunks.slice(chunkIndex, chunks.length - 1).forEach(function (chunk) {\n        if (settings.arrayNumeric && isFinite(chunk)) {\n          $macgyver.utils.set(node, chunk, []);\n        } else {\n          $macgyver.utils.set(node, chunk, {});\n        }\n\n        node = node[chunk];\n      });\n      $macgyver.utils.set(node, chunks[chunks.length - 1], value);\n      return true;\n    } else {\n      node = node[chunk];\n      return false;\n    }\n  });\n  return value;\n};\n/**\n* Mapping around Vue.set (if its available) or simple key/val setting\n* @param {Object} target The target object to mutate\n* @param {string} key The key to set\n* @param {*} val The value to set\n* @returns {*} The set value\n*/\n\n\n$macgyver.utils.set = $macgyver.utils.global.Vue ? Vue.set : function (target, key, val) {\n  return target[key] = val;\n};\n/**\n* Mapping around Vue.unset (if its available) or simple key delettion\n* @param {Object} target The target object to mutate\n* @param {string} key The key to remove\n*/\n\n$macgyver.utils.unset = $macgyver.utils.global.Vue ? Vue.unset : function (target, key) {\n  delete target[key];\n};\n/**\n* Provides a function to quickly get a data path on a Vue component by its path\n* This function is designed to work as simillaly as possible to _.get()\n* @param {Object} target The source object, usually the root controller\n* @param {string|array} path Either a path in dotted or array notation\n* @param {*} [fallback=undefined] Optional fallback to return if no value is found\n* @returns {*} Either the found value or the fallback\n*/\n\n$macgyver.utils.getPath = function (target, path, fallback) {\n  return lodash__WEBPACK_IMPORTED_MODULE_0___default().get(target, path, fallback);\n};\n/**\n* Attempt to increment a string ID\n* This is usually used when we have a base ID and want to duplicate the widget\n* If ID is blank, blank is returned (assumes base parent also has no ID)\n* @param {string} str The string to increment\n* @returns {string} An incremented version of str\n*/\n\n\n$macgyver.utils.incrementId = function (str) {\n  if (!str) {\n    return str;\n  } else if (/[0-9]$/.test(str)) {\n    // Ends in a number\n    var extracted = /*#__PURE__*/_wrapRegExp(/^(.*)([0-9]+)$/, {\n      prefix: 1,\n      numeric: 2\n    }).exec(str); // Extract numeric suffix\n\n\n    return extracted.groups.prefix + (parseInt(extracted.groups.prefix) + 1);\n  } else {\n    // No idea - just append '2'\n    return str + '2';\n  }\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ($macgyver);\n\n//# sourceURL=webpack://@momsfriendlydevco/macgyver/./src/macgyver.js?");

/***/ }),

/***/ "./node_modules/sift/es5m/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sift/es5m/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$Size\": () => (/* binding */ $Size),\n/* harmony export */   \"$all\": () => (/* binding */ $all),\n/* harmony export */   \"$and\": () => (/* binding */ $and),\n/* harmony export */   \"$elemMatch\": () => (/* binding */ $elemMatch),\n/* harmony export */   \"$eq\": () => (/* binding */ $eq),\n/* harmony export */   \"$exists\": () => (/* binding */ $exists),\n/* harmony export */   \"$gt\": () => (/* binding */ $gt),\n/* harmony export */   \"$gte\": () => (/* binding */ $gte),\n/* harmony export */   \"$in\": () => (/* binding */ $in),\n/* harmony export */   \"$lt\": () => (/* binding */ $lt),\n/* harmony export */   \"$lte\": () => (/* binding */ $lte),\n/* harmony export */   \"$mod\": () => (/* binding */ $mod),\n/* harmony export */   \"$ne\": () => (/* binding */ $ne),\n/* harmony export */   \"$nin\": () => (/* binding */ $nin),\n/* harmony export */   \"$nor\": () => (/* binding */ $nor),\n/* harmony export */   \"$not\": () => (/* binding */ $not),\n/* harmony export */   \"$options\": () => (/* binding */ $options),\n/* harmony export */   \"$or\": () => (/* binding */ $or),\n/* harmony export */   \"$regex\": () => (/* binding */ $regex),\n/* harmony export */   \"$size\": () => (/* binding */ $size),\n/* harmony export */   \"$type\": () => (/* binding */ $type),\n/* harmony export */   \"$where\": () => (/* binding */ $where),\n/* harmony export */   \"EqualsOperation\": () => (/* binding */ EqualsOperation),\n/* harmony export */   \"createDefaultQueryOperation\": () => (/* binding */ createDefaultQueryOperation),\n/* harmony export */   \"createEqualsOperation\": () => (/* binding */ createEqualsOperation),\n/* harmony export */   \"createOperationTester\": () => (/* binding */ createOperationTester),\n/* harmony export */   \"createQueryOperation\": () => (/* binding */ createQueryOperation),\n/* harmony export */   \"createQueryTester\": () => (/* binding */ createQueryTester),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\nvar typeChecker = function (type) {\n    var typeString = \"[object \" + type + \"]\";\n    return function (value) {\n        return getClassName(value) === typeString;\n    };\n};\nvar getClassName = function (value) { return Object.prototype.toString.call(value); };\nvar comparable = function (value) {\n    if (value instanceof Date) {\n        return value.getTime();\n    }\n    else if (isArray(value)) {\n        return value.map(comparable);\n    }\n    else if (value && typeof value.toJSON === \"function\") {\n        return value.toJSON();\n    }\n    return value;\n};\nvar isArray = typeChecker(\"Array\");\nvar isObject = typeChecker(\"Object\");\nvar isFunction = typeChecker(\"Function\");\nvar isVanillaObject = function (value) {\n    return (value &&\n        (value.constructor === Object ||\n            value.constructor === Array ||\n            value.constructor.toString() === \"function Object() { [native code] }\" ||\n            value.constructor.toString() === \"function Array() { [native code] }\") &&\n        !value.toJSON);\n};\nvar equals = function (a, b) {\n    if (a == null && a == b) {\n        return true;\n    }\n    if (a === b) {\n        return true;\n    }\n    if (Object.prototype.toString.call(a) !== Object.prototype.toString.call(b)) {\n        return false;\n    }\n    if (isArray(a)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (var i = 0, length_1 = a.length; i < length_1; i++) {\n            if (!equals(a[i], b[i]))\n                return false;\n        }\n        return true;\n    }\n    else if (isObject(a)) {\n        if (Object.keys(a).length !== Object.keys(b).length) {\n            return false;\n        }\n        for (var key in a) {\n            if (!equals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return false;\n};\n\n/**\n * Walks through each value given the context - used for nested operations. E.g:\n * { \"person.address\": { $eq: \"blarg\" }}\n */\nvar walkKeyPathValues = function (item, keyPath, next, depth, key, owner) {\n    var currentKey = keyPath[depth];\n    // if array, then try matching. Might fall through for cases like:\n    // { $eq: [1, 2, 3] }, [ 1, 2, 3 ].\n    if (isArray(item) && isNaN(Number(currentKey))) {\n        for (var i = 0, length_1 = item.length; i < length_1; i++) {\n            // if FALSE is returned, then terminate walker. For operations, this simply\n            // means that the search critera was met.\n            if (!walkKeyPathValues(item[i], keyPath, next, depth, i, item)) {\n                return false;\n            }\n        }\n    }\n    if (depth === keyPath.length || item == null) {\n        return next(item, key, owner, depth === 0);\n    }\n    return walkKeyPathValues(item[currentKey], keyPath, next, depth + 1, currentKey, item);\n};\nvar BaseOperation = /** @class */ (function () {\n    function BaseOperation(params, owneryQuery, options, name) {\n        this.params = params;\n        this.owneryQuery = owneryQuery;\n        this.options = options;\n        this.name = name;\n        this.init();\n    }\n    BaseOperation.prototype.init = function () { };\n    BaseOperation.prototype.reset = function () {\n        this.done = false;\n        this.keep = false;\n    };\n    return BaseOperation;\n}());\nvar GroupOperation = /** @class */ (function (_super) {\n    __extends(GroupOperation, _super);\n    function GroupOperation(params, owneryQuery, options, children) {\n        var _this = _super.call(this, params, owneryQuery, options) || this;\n        _this.children = children;\n        return _this;\n    }\n    /**\n     */\n    GroupOperation.prototype.reset = function () {\n        this.keep = false;\n        this.done = false;\n        for (var i = 0, length_2 = this.children.length; i < length_2; i++) {\n            this.children[i].reset();\n        }\n    };\n    /**\n     */\n    GroupOperation.prototype.childrenNext = function (item, key, owner, root) {\n        var done = true;\n        var keep = true;\n        for (var i = 0, length_3 = this.children.length; i < length_3; i++) {\n            var childOperation = this.children[i];\n            if (!childOperation.done) {\n                childOperation.next(item, key, owner, root);\n            }\n            if (!childOperation.keep) {\n                keep = false;\n            }\n            if (childOperation.done) {\n                if (!childOperation.keep) {\n                    break;\n                }\n            }\n            else {\n                done = false;\n            }\n        }\n        this.done = done;\n        this.keep = keep;\n    };\n    return GroupOperation;\n}(BaseOperation));\nvar NamedGroupOperation = /** @class */ (function (_super) {\n    __extends(NamedGroupOperation, _super);\n    function NamedGroupOperation(params, owneryQuery, options, children, name) {\n        var _this = _super.call(this, params, owneryQuery, options, children) || this;\n        _this.name = name;\n        return _this;\n    }\n    return NamedGroupOperation;\n}(GroupOperation));\nvar QueryOperation = /** @class */ (function (_super) {\n    __extends(QueryOperation, _super);\n    function QueryOperation() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    /**\n     */\n    QueryOperation.prototype.next = function (item, key, parent, root) {\n        this.childrenNext(item, key, parent, root);\n    };\n    return QueryOperation;\n}(GroupOperation));\nvar NestedOperation = /** @class */ (function (_super) {\n    __extends(NestedOperation, _super);\n    function NestedOperation(keyPath, params, owneryQuery, options, children) {\n        var _this = _super.call(this, params, owneryQuery, options, children) || this;\n        _this.keyPath = keyPath;\n        _this.propop = true;\n        /**\n         */\n        _this._nextNestedValue = function (value, key, owner, root) {\n            _this.childrenNext(value, key, owner, root);\n            return !_this.done;\n        };\n        return _this;\n    }\n    /**\n     */\n    NestedOperation.prototype.next = function (item, key, parent) {\n        walkKeyPathValues(item, this.keyPath, this._nextNestedValue, 0, key, parent);\n    };\n    return NestedOperation;\n}(GroupOperation));\nvar createTester = function (a, compare) {\n    if (a instanceof Function) {\n        return a;\n    }\n    if (a instanceof RegExp) {\n        return function (b) {\n            var result = typeof b === \"string\" && a.test(b);\n            a.lastIndex = 0;\n            return result;\n        };\n    }\n    var comparableA = comparable(a);\n    return function (b) { return compare(comparableA, comparable(b)); };\n};\nvar EqualsOperation = /** @class */ (function (_super) {\n    __extends(EqualsOperation, _super);\n    function EqualsOperation() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    EqualsOperation.prototype.init = function () {\n        this._test = createTester(this.params, this.options.compare);\n    };\n    EqualsOperation.prototype.next = function (item, key, parent) {\n        if (!Array.isArray(parent) || parent.hasOwnProperty(key)) {\n            if (this._test(item, key, parent)) {\n                this.done = true;\n                this.keep = true;\n            }\n        }\n    };\n    return EqualsOperation;\n}(BaseOperation));\nvar createEqualsOperation = function (params, owneryQuery, options) { return new EqualsOperation(params, owneryQuery, options); };\nvar NopeOperation = /** @class */ (function (_super) {\n    __extends(NopeOperation, _super);\n    function NopeOperation() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    NopeOperation.prototype.next = function () {\n        this.done = true;\n        this.keep = false;\n    };\n    return NopeOperation;\n}(BaseOperation));\nvar numericalOperationCreator = function (createNumericalOperation) { return function (params, owneryQuery, options, name) {\n    if (params == null) {\n        return new NopeOperation(params, owneryQuery, options, name);\n    }\n    return createNumericalOperation(params, owneryQuery, options, name);\n}; };\nvar numericalOperation = function (createTester) {\n    return numericalOperationCreator(function (params, owneryQuery, options, name) {\n        var typeofParams = typeof comparable(params);\n        var test = createTester(params);\n        return new EqualsOperation(function (b) {\n            return typeof comparable(b) === typeofParams && test(b);\n        }, owneryQuery, options, name);\n    });\n};\nvar createNamedOperation = function (name, params, parentQuery, options) {\n    var operationCreator = options.operations[name];\n    if (!operationCreator) {\n        throwUnsupportedOperation(name);\n    }\n    return operationCreator(params, parentQuery, options, name);\n};\nvar throwUnsupportedOperation = function (name) {\n    throw new Error(\"Unsupported operation: \" + name);\n};\nvar containsOperation = function (query, options) {\n    for (var key in query) {\n        if (options.operations.hasOwnProperty(key) || key.charAt(0) === \"$\")\n            return true;\n    }\n    return false;\n};\nvar createNestedOperation = function (keyPath, nestedQuery, parentKey, owneryQuery, options) {\n    if (containsOperation(nestedQuery, options)) {\n        var _a = createQueryOperations(nestedQuery, parentKey, options), selfOperations = _a[0], nestedOperations = _a[1];\n        if (nestedOperations.length) {\n            throw new Error(\"Property queries must contain only operations, or exact objects.\");\n        }\n        return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, selfOperations);\n    }\n    return new NestedOperation(keyPath, nestedQuery, owneryQuery, options, [\n        new EqualsOperation(nestedQuery, owneryQuery, options)\n    ]);\n};\nvar createQueryOperation = function (query, owneryQuery, _a) {\n    if (owneryQuery === void 0) { owneryQuery = null; }\n    var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;\n    var options = {\n        compare: compare || equals,\n        operations: Object.assign({}, operations || {})\n    };\n    var _c = createQueryOperations(query, null, options), selfOperations = _c[0], nestedOperations = _c[1];\n    var ops = [];\n    if (selfOperations.length) {\n        ops.push(new NestedOperation([], query, owneryQuery, options, selfOperations));\n    }\n    ops.push.apply(ops, nestedOperations);\n    if (ops.length === 1) {\n        return ops[0];\n    }\n    return new QueryOperation(query, owneryQuery, options, ops);\n};\nvar createQueryOperations = function (query, parentKey, options) {\n    var selfOperations = [];\n    var nestedOperations = [];\n    if (!isVanillaObject(query)) {\n        selfOperations.push(new EqualsOperation(query, query, options));\n        return [selfOperations, nestedOperations];\n    }\n    for (var key in query) {\n        if (options.operations.hasOwnProperty(key)) {\n            var op = createNamedOperation(key, query[key], query, options);\n            if (op) {\n                if (!op.propop && parentKey && !options.operations[parentKey]) {\n                    throw new Error(\"Malformed query. \" + key + \" cannot be matched against property.\");\n                }\n            }\n            // probably just a flag for another operation (like $options)\n            if (op != null) {\n                selfOperations.push(op);\n            }\n        }\n        else if (key.charAt(0) === \"$\") {\n            throwUnsupportedOperation(key);\n        }\n        else {\n            nestedOperations.push(createNestedOperation(key.split(\".\"), query[key], key, query, options));\n        }\n    }\n    return [selfOperations, nestedOperations];\n};\nvar createOperationTester = function (operation) { return function (item, key, owner) {\n    operation.reset();\n    operation.next(item, key, owner);\n    return operation.keep;\n}; };\nvar createQueryTester = function (query, options) {\n    if (options === void 0) { options = {}; }\n    return createOperationTester(createQueryOperation(query, null, options));\n};\n\nvar $Ne = /** @class */ (function (_super) {\n    __extends($Ne, _super);\n    function $Ne() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $Ne.prototype.init = function () {\n        this._test = createTester(this.params, this.options.compare);\n    };\n    $Ne.prototype.reset = function () {\n        _super.prototype.reset.call(this);\n        this.keep = true;\n    };\n    $Ne.prototype.next = function (item) {\n        if (this._test(item)) {\n            this.done = true;\n            this.keep = false;\n        }\n    };\n    return $Ne;\n}(BaseOperation));\n// https://docs.mongodb.com/manual/reference/operator/query/elemMatch/\nvar $ElemMatch = /** @class */ (function (_super) {\n    __extends($ElemMatch, _super);\n    function $ElemMatch() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $ElemMatch.prototype.init = function () {\n        if (!this.params || typeof this.params !== \"object\") {\n            throw new Error(\"Malformed query. $elemMatch must by an object.\");\n        }\n        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);\n    };\n    $ElemMatch.prototype.reset = function () {\n        _super.prototype.reset.call(this);\n        this._queryOperation.reset();\n    };\n    $ElemMatch.prototype.next = function (item) {\n        if (isArray(item)) {\n            for (var i = 0, length_1 = item.length; i < length_1; i++) {\n                // reset query operation since item being tested needs to pass _all_ query\n                // operations for it to be a success\n                this._queryOperation.reset();\n                var child = item[i];\n                this._queryOperation.next(child, i, item, false);\n                this.keep = this.keep || this._queryOperation.keep;\n            }\n            this.done = true;\n        }\n        else {\n            this.done = false;\n            this.keep = false;\n        }\n    };\n    return $ElemMatch;\n}(BaseOperation));\nvar $Not = /** @class */ (function (_super) {\n    __extends($Not, _super);\n    function $Not() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $Not.prototype.init = function () {\n        this._queryOperation = createQueryOperation(this.params, this.owneryQuery, this.options);\n    };\n    $Not.prototype.reset = function () {\n        _super.prototype.reset.call(this);\n        this._queryOperation.reset();\n    };\n    $Not.prototype.next = function (item, key, owner, root) {\n        this._queryOperation.next(item, key, owner, root);\n        this.done = this._queryOperation.done;\n        this.keep = !this._queryOperation.keep;\n    };\n    return $Not;\n}(BaseOperation));\nvar $Size = /** @class */ (function (_super) {\n    __extends($Size, _super);\n    function $Size() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $Size.prototype.init = function () { };\n    $Size.prototype.next = function (item) {\n        if (isArray(item) && item.length === this.params) {\n            this.done = true;\n            this.keep = true;\n        }\n        // if (parent && parent.length === this.params) {\n        //   this.done = true;\n        //   this.keep = true;\n        // }\n    };\n    return $Size;\n}(BaseOperation));\nvar assertGroupNotEmpty = function (values) {\n    if (values.length === 0) {\n        throw new Error(\"$and/$or/$nor must be a nonempty array\");\n    }\n};\nvar $Or = /** @class */ (function (_super) {\n    __extends($Or, _super);\n    function $Or() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = false;\n        return _this;\n    }\n    $Or.prototype.init = function () {\n        var _this = this;\n        assertGroupNotEmpty(this.params);\n        this._ops = this.params.map(function (op) {\n            return createQueryOperation(op, null, _this.options);\n        });\n    };\n    $Or.prototype.reset = function () {\n        this.done = false;\n        this.keep = false;\n        for (var i = 0, length_2 = this._ops.length; i < length_2; i++) {\n            this._ops[i].reset();\n        }\n    };\n    $Or.prototype.next = function (item, key, owner) {\n        var done = false;\n        var success = false;\n        for (var i = 0, length_3 = this._ops.length; i < length_3; i++) {\n            var op = this._ops[i];\n            op.next(item, key, owner);\n            if (op.keep) {\n                done = true;\n                success = op.keep;\n                break;\n            }\n        }\n        this.keep = success;\n        this.done = done;\n    };\n    return $Or;\n}(BaseOperation));\nvar $Nor = /** @class */ (function (_super) {\n    __extends($Nor, _super);\n    function $Nor() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = false;\n        return _this;\n    }\n    $Nor.prototype.next = function (item, key, owner) {\n        _super.prototype.next.call(this, item, key, owner);\n        this.keep = !this.keep;\n    };\n    return $Nor;\n}($Or));\nvar $In = /** @class */ (function (_super) {\n    __extends($In, _super);\n    function $In() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $In.prototype.init = function () {\n        var _this = this;\n        this._testers = this.params.map(function (value) {\n            if (containsOperation(value, _this.options)) {\n                throw new Error(\"cannot nest $ under \" + _this.name.toLowerCase());\n            }\n            return createTester(value, _this.options.compare);\n        });\n    };\n    $In.prototype.next = function (item, key, owner) {\n        var done = false;\n        var success = false;\n        for (var i = 0, length_4 = this._testers.length; i < length_4; i++) {\n            var test = this._testers[i];\n            if (test(item)) {\n                done = true;\n                success = true;\n                break;\n            }\n        }\n        this.keep = success;\n        this.done = done;\n    };\n    return $In;\n}(BaseOperation));\nvar $Nin = /** @class */ (function (_super) {\n    __extends($Nin, _super);\n    function $Nin(params, ownerQuery, options, name) {\n        var _this = _super.call(this, params, ownerQuery, options, name) || this;\n        _this.propop = true;\n        _this._in = new $In(params, ownerQuery, options, name);\n        return _this;\n    }\n    $Nin.prototype.next = function (item, key, owner, root) {\n        this._in.next(item, key, owner);\n        if (isArray(owner) && !root) {\n            if (this._in.keep) {\n                this.keep = false;\n                this.done = true;\n            }\n            else if (key == owner.length - 1) {\n                this.keep = true;\n                this.done = true;\n            }\n        }\n        else {\n            this.keep = !this._in.keep;\n            this.done = true;\n        }\n    };\n    $Nin.prototype.reset = function () {\n        _super.prototype.reset.call(this);\n        this._in.reset();\n    };\n    return $Nin;\n}(BaseOperation));\nvar $Exists = /** @class */ (function (_super) {\n    __extends($Exists, _super);\n    function $Exists() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $Exists.prototype.next = function (item, key, owner) {\n        if (owner.hasOwnProperty(key) === this.params) {\n            this.done = true;\n            this.keep = true;\n        }\n    };\n    return $Exists;\n}(BaseOperation));\nvar $And = /** @class */ (function (_super) {\n    __extends($And, _super);\n    function $And(params, owneryQuery, options, name) {\n        var _this = _super.call(this, params, owneryQuery, options, params.map(function (query) { return createQueryOperation(query, owneryQuery, options); }), name) || this;\n        _this.propop = false;\n        assertGroupNotEmpty(params);\n        return _this;\n    }\n    $And.prototype.next = function (item, key, owner, root) {\n        this.childrenNext(item, key, owner, root);\n    };\n    return $And;\n}(NamedGroupOperation));\nvar $All = /** @class */ (function (_super) {\n    __extends($All, _super);\n    function $All(params, owneryQuery, options, name) {\n        var _this = _super.call(this, params, owneryQuery, options, params.map(function (query) { return createQueryOperation(query, owneryQuery, options); }), name) || this;\n        _this.propop = true;\n        return _this;\n    }\n    $All.prototype.next = function (item, key, owner, root) {\n        this.childrenNext(item, key, owner, root);\n    };\n    return $All;\n}(NamedGroupOperation));\nvar $eq = function (params, owneryQuery, options) {\n    return new EqualsOperation(params, owneryQuery, options);\n};\nvar $ne = function (params, owneryQuery, options, name) { return new $Ne(params, owneryQuery, options, name); };\nvar $or = function (params, owneryQuery, options, name) { return new $Or(params, owneryQuery, options, name); };\nvar $nor = function (params, owneryQuery, options, name) { return new $Nor(params, owneryQuery, options, name); };\nvar $elemMatch = function (params, owneryQuery, options, name) { return new $ElemMatch(params, owneryQuery, options, name); };\nvar $nin = function (params, owneryQuery, options, name) { return new $Nin(params, owneryQuery, options, name); };\nvar $in = function (params, owneryQuery, options, name) {\n    return new $In(params, owneryQuery, options, name);\n};\nvar $lt = numericalOperation(function (params) { return function (b) { return b < params; }; });\nvar $lte = numericalOperation(function (params) { return function (b) { return b <= params; }; });\nvar $gt = numericalOperation(function (params) { return function (b) { return b > params; }; });\nvar $gte = numericalOperation(function (params) { return function (b) { return b >= params; }; });\nvar $mod = function (_a, owneryQuery, options) {\n    var mod = _a[0], equalsValue = _a[1];\n    return new EqualsOperation(function (b) { return comparable(b) % mod === equalsValue; }, owneryQuery, options);\n};\nvar $exists = function (params, owneryQuery, options, name) { return new $Exists(params, owneryQuery, options, name); };\nvar $regex = function (pattern, owneryQuery, options) {\n    return new EqualsOperation(new RegExp(pattern, owneryQuery.$options), owneryQuery, options);\n};\nvar $not = function (params, owneryQuery, options, name) { return new $Not(params, owneryQuery, options, name); };\nvar typeAliases = {\n    number: function (v) { return typeof v === \"number\"; },\n    string: function (v) { return typeof v === \"string\"; },\n    bool: function (v) { return typeof v === \"boolean\"; },\n    array: function (v) { return Array.isArray(v); },\n    null: function (v) { return v === null; },\n    timestamp: function (v) { return v instanceof Date; }\n};\nvar $type = function (clazz, owneryQuery, options) {\n    return new EqualsOperation(function (b) {\n        if (typeof clazz === \"string\") {\n            if (!typeAliases[clazz]) {\n                throw new Error(\"Type alias does not exist\");\n            }\n            return typeAliases[clazz](b);\n        }\n        return b != null ? b instanceof clazz || b.constructor === clazz : false;\n    }, owneryQuery, options);\n};\nvar $and = function (params, ownerQuery, options, name) { return new $And(params, ownerQuery, options, name); };\nvar $all = function (params, ownerQuery, options, name) { return new $All(params, ownerQuery, options, name); };\nvar $size = function (params, ownerQuery, options) { return new $Size(params, ownerQuery, options, \"$size\"); };\nvar $options = function () { return null; };\nvar $where = function (params, ownerQuery, options) {\n    var test;\n    if (isFunction(params)) {\n        test = params;\n    }\n    else if (!process.env.CSP_ENABLED) {\n        test = new Function(\"obj\", \"return \" + params);\n    }\n    else {\n        throw new Error(\"In CSP mode, sift does not support strings in \\\"$where\\\" condition\");\n    }\n    return new EqualsOperation(function (b) { return test.bind(b)(b); }, ownerQuery, options);\n};\n\nvar defaultOperations = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    $Size: $Size,\n    $eq: $eq,\n    $ne: $ne,\n    $or: $or,\n    $nor: $nor,\n    $elemMatch: $elemMatch,\n    $nin: $nin,\n    $in: $in,\n    $lt: $lt,\n    $lte: $lte,\n    $gt: $gt,\n    $gte: $gte,\n    $mod: $mod,\n    $exists: $exists,\n    $regex: $regex,\n    $not: $not,\n    $type: $type,\n    $and: $and,\n    $all: $all,\n    $size: $size,\n    $options: $options,\n    $where: $where\n});\n\nvar createDefaultQueryOperation = function (query, ownerQuery, _a) {\n    var _b = _a === void 0 ? {} : _a, compare = _b.compare, operations = _b.operations;\n    return createQueryOperation(query, ownerQuery, {\n        compare: compare,\n        operations: Object.assign({}, defaultOperations, operations || {})\n    });\n};\nvar createDefaultQueryTester = function (query, options) {\n    if (options === void 0) { options = {}; }\n    var op = createDefaultQueryOperation(query, null, options);\n    return createOperationTester(op);\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createDefaultQueryTester);\n\n//# sourceMappingURL=index.js.map\n\n\n//# sourceURL=webpack://@momsfriendlydevco/macgyver/./node_modules/sift/es5m/index.js?");

/***/ }),

/***/ "lodash":
/*!*************************************************************************************!*\
  !*** external {"commonjs":"lodash","commonjs2":"lodash","amd":"lodash","root":"_"} ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/entrypoint-node.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});