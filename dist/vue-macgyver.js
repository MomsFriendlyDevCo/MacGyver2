/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return (this["webpackChunk_momsfriendlydevco_macgyver"] = this["webpackChunk_momsfriendlydevco_macgyver"] || []).push([["vue-macgyver"],{

/***/ "./node_modules/@momsfriendlydevco/vue-setpath/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@momsfriendlydevco/vue-setpath/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n* Set a dotted notation or array path to a set value\n* This function will correctly populate any missing entities, calling vm.$set on each traversal of the path\n* Passing undefined as a value removes the key (unless removeUndefined is set to false)\n*\n* @param {Object} [target] The target to set the path of, if omitted the `vm` object is used as the base for traversal \n* @param {string|array} path The path to set within the target / vm\n* @param {*} value The value to set\n* @param {Object} [options] Additional options\n* @param {boolean} [options.arrayNumeric=true] Process numeric path segments as arrays\n* @param {boolean} [options.removeUndefined=true] If undefined is specified as a value the key is removed instead of being set\n* @param {boolean} [options.debug=false] Also print out debugging information when setting the value\n* @returns {Object} The set value, like $set()\n*\n* @example Set a deeply nested path within a target object\n* vm.$setPath(this, 'foo.bar.baz', 123); // this.$data.foo.bar.baz = 123\n*\n* @example Set a deeply nested path, with arrays, assuming VM as the root node\n* vm.$setPath('foo.1.bar', 123); // vm.$data.foo = [{bar: 123}]\n*/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n\tinstall: function(app, options) {\n\t\tapp.mixin({\n\t\t\tmethods: {\n\t\t\t\t$setPath: function(target, path, value, options) {\n\t\t\t\t\t// Argument mangling {{{\n\t\t\t\t\tif (_.isString(target) || _.isArray(target) || value === undefined) { // called as (path, value)\n\t\t\t\t\t\t[target, path, value, options] = [this, target, path, value];\n\t\t\t\t\t} else if (!_.isObject(target)) {\n\t\t\t\t\t\tthrow new Error('Cannot use $setPath on non-object target');\n\t\t\t\t\t}\n\t\t\t\t\t// }}}\n\n\t\t\t\t\tvar settings = {\n\t\t\t\t\t\tarrayNumeric: true,\n\t\t\t\t\t\tdebug: false,\n\t\t\t\t\t\tremoveUndefined: true,\n\t\t\t\t\t\t...options,\n\t\t\t\t\t};\n\n\t\t\t\t\tif (settings.debug) console.log('[$setPath]', path, '=', value, {target, options});\n\n\t\t\t\t\tvar node = target;\n\t\t\t\t\tif (!path) throw new Error('Cannot $setPath with undefined path');\n\t\t\t\t\t(_.isString(path) ? path.split('.') : path).some((chunk, chunkIndex, chunks) => {\n\t\t\t\t\t\tif (chunkIndex == chunks.length - 1) { // Leaf node\n\t\t\t\t\t\t\tif (settings.removeUndefined && value === undefined) {\n\t\t\t\t\t\t\t\tthis.$unset(node, chunk);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.$set(node, chunk, value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (node[chunk] === undefined) { // This chunk (and all following chunks) does't exist - populate from here\n\t\t\t\t\t\t\tchunks.slice(chunkIndex, chunks.length - 1).forEach(chunk => {\n\t\t\t\t\t\t\t\tif (settings.arrayNumeric && isFinite(chunk)) {\n\t\t\t\t\t\t\t\t\tthis.$set(node, chunk, []);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.$set(node, chunk, {});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tnode = node[chunk];\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tthis.$set(node, chunks[chunks.length - 1], value);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode = node[chunk];\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t}\n\t\t});\n\t}\n});\n\n//# sourceURL=webpack://@momsfriendlydevco/macgyver/./node_modules/@momsfriendlydevco/vue-setpath/index.js?");

/***/ }),

/***/ "./src/libs/emit.js":
/*!**************************!*\
  !*** ./src/libs/emit.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar methods = {}; // Method's to glue onto vm.$emit\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  install: function install(app, options) {\n    /**\n    * Extend the base app.vue.prototye.$emit with app.vue.prototye.$emit.broadcast()\n    * This is effectively the same as an $emit.down from the root node\n    * NOTE: This also broadcasts to app.vue\n    * @param {string} msg The name of the event to emit\n    * @param {*} [payload...] The payload of the event\n    */\n    app.broadcast = methods.broadcast = function (msg) {\n      var _app$vue$$emit, _app$vue$$emit$down;\n\n      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        payload[_key - 1] = arguments[_key];\n      }\n\n      // FIXME: This mock Vue3 global is a little strange here.\n      (_app$vue$$emit = app.vue.$emit).call.apply(_app$vue$$emit, [app.vue, msg].concat(payload));\n\n      (_app$vue$$emit$down = app.vue.$emit.down).call.apply(_app$vue$$emit$down, [app.vue, msg].concat(payload));\n    };\n    /**\n    * Extend the base app.vue.prototye.$emit with app.vue.prototye.$emit.down() which recurses though all children emitting a message\n    * NOTE: This does not include the current component level, only the children\n    * @param {string} msg The name of the event to emit\n    * @param {*} [payload...] The payload of the event\n    * @returns {VueComponent} This chainable VM\n    */\n\n\n    methods.down = function (msg) {\n      for (var _len2 = arguments.length, payload = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        payload[_key2 - 1] = arguments[_key2];\n      }\n\n      this.$children.forEach(function (child) {\n        var _child$$emit, _child$$emit$down;\n\n        (_child$$emit = child.$emit).call.apply(_child$$emit, [child, msg].concat(payload));\n\n        (_child$$emit$down = child.$emit.down).call.apply(_child$$emit$down, [child, msg].concat(payload));\n      });\n      return this;\n    };\n    /**\n    * Extend the base methods.$emit with app.vue.prototye.$emit.up() which recurses though all parents emitting a message\n    * NOTE: This does not include the current component level, only the parents\n    * @param {string} msg The name of the event to emit\n    * @param {*} [payload...] The payload of the event\n    * @returns {VueComponent} This chainable VM\n    */\n\n\n    methods.up = function (msg) {\n      if (!this || !this.$parent) throw new Error('Unable to $emit.up() on non Vue component');\n      var node = this;\n\n      for (var _len3 = arguments.length, payload = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        payload[_key3 - 1] = arguments[_key3];\n      }\n\n      while (node.$parent) {\n        var _node$$emit;\n\n        node = node.$parent;\n\n        (_node$$emit = node.$emit).call.apply(_node$$emit, [node, msg].concat(payload));\n      }\n\n      return this;\n    };\n    /**\n    * Extend the base app.vue.prototye.$emit with promise support\n    * Any function returning a promise will be waited on\n    * NOTE: As of 2019-07-10 (Vue 2.6.10) it is not possible to glue this as vm.$emit.promise for some reason, maybe one day this will change\n    * @param {string} msg The name of the event to emit\n    * @param {*} [payload...] The payload of the event\n    * @returns {Promise} A promise which will resolve with the Promise.all result of all listeners\n    */\n\n\n    methods.promise = function (msg) {\n      for (var _len4 = arguments.length, payload = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        payload[_key4 - 1] = arguments[_key4];\n      }\n\n      var node = this;\n      if (!node || !this._isVue) throw new Error('Unable to $emit.promise() on non Vue component');\n      if (!node._events[msg] || !this._events[msg].length) return Promise.resolve(); // No listeners anyway\n\n      return Promise.all(node._events[msg].map(function (e) {\n        return Promise.resolve(e.apply(node, payload));\n      })).then(function (responses) {\n        return responses[0];\n      });\n    };\n    /**\n    * Return if anything is listening to a given event\n    * This is useful if the event broadcast would involve some non-trivial processing and it would be beneficial to skip if nothing is listening anyway\n    * @param {string} msg The name of the event to emit\n    * @returns {boolean} Boolean true if any matching listener is present\n    */\n\n\n    methods.hasListeners = function (msg) {\n      if (!this || !this.$parent) throw new Error('Unable to $emit.hasSubscribers() on non Vue component');\n      return this._events[msg] && this._events[msg].length > 0;\n    };\n    /**\n    * Auto emit a message on a timer\n    * If any listener returns a promise it is waited on\n    * @param {string} msg The name of the event to emit\n    * @param {*} [payload...] Optional additional payload for the event\n    * @param {number} interval When to schedule the event, required and must be numeric\n    * @returns {VueComponent} This chainable VM\n    */\n\n\n    methods.schedule = function (msg) {\n      var _this = this;\n\n      if (!this || !this.$parent) throw new Error('Unable to $emit.schedule() on non Vue component');\n      if (!this.$emit.scheduleHandles) this.$emit.scheduleHandles = {};\n\n      for (var _len5 = arguments.length, payload = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        payload[_key5 - 1] = arguments[_key5];\n      }\n\n      var interval = payload.pop();\n      if (typeof interval != 'number') throw new Error('Last argument to $emit.auto must be a numeric interval');\n      this.$emit.scheduleHandles[msg] = {\n        message: msg,\n        payload: payload,\n        interval: interval,\n        timer: undefined,\n        reschedule: function reschedule() {\n          _this.$emit.scheduleHandles[msg].timer = setTimeout(function () {\n            var _this$$emit;\n\n            if (!_this || !_this.$emit.scheduleHandles[msg]) return console.log('Timer event for destroyed VueComponent');\n\n            (_this$$emit = _this.$emit).promise.apply(_this$$emit, [_this.$emit.scheduleHandles[msg].message].concat(_toConsumableArray(_this.$emit.scheduleHandles[msg].payload))).then(function () {\n              return _this.$emit.scheduleHandles[msg].reschedule;\n            });\n          }, _this.$emit.scheduleHandles[msg].interval);\n        }\n      };\n      this.$emit.scheduleHandles[msg].reschedule(); // Schedule initial timer\n\n      return this;\n    };\n    /**\n    * Release an scheduled emitter\n    * If called with no arguments all scheduled timers are released\n    * This function is called automatically whenever a VM is being destroyed\n    * @param {string|array<string>} [msgs] Messages to unschedule, if omitted all are assumed\n    * @returns {VueComponent} This chainable VM\n    */\n\n\n    methods.unschedule = function (msgs) {\n      var _this2 = this;\n\n      if (!this.$emit.scheduleHandles) return; // Nothing scheduled anyway\n\n      _.castArray(msgs || Object.keys(this.$emit.scheduleHandles)).forEach(function (msg) {\n        clearTimeout(_this2.$emit.scheduleHandles[msg]);\n        delete _this2.$emit.scheduleHandles[msg];\n      });\n    };\n\n    app.mixin({\n      beforeCreate: function beforeCreate() {\n        var _this3 = this;\n\n        this.$emit = this.$emit.bind(this); // Rebind $emit to this vm so we get the right context\n        // Long-winded version of _.mapValues() where we remap each method to a binding of this VM\n\n        Object.assign(this.$emit, Object.fromEntries(Object.entries(methods).map(function (i) {\n          return [i[0], i[1].bind(_this3)];\n        })));\n      },\n      beforeDestroy: function beforeDestroy() {\n        this.$emit.unschedule();\n      }\n    });\n  }\n});\n\n//# sourceURL=webpack://@momsfriendlydevco/macgyver/./src/libs/emit.js?");

/***/ }),

/***/ "./src/libs/watchAll.js":
/*!******************************!*\
  !*** ./src/libs/watchAll.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n* Binds a simple vm.$watchAll([props...], handler) function into the prototype scope\n* This works similar to the Angular vm.$watch([...]) function\n* @param {array <string|array>} props Named properties within `vm` to watch, dotted notation or array notation is supported\n* @param {function} callback The callback to run when the watch triggers\n* @param {Object} [options] Additional options\n* @param {boolean} [options.immediate=false] Execute the callback immediately on register, needAll can cause the callback not to fire if all required paths are not available yet\n* @param {boolean} [options.needAll=false] Only fire the watcher when every single member listed has a non-undefined value\n* @param {boolean} [options.needAllLock=true] WHether, after seeing all paths, we ALWAYS route to the callback in future, even if the values become undefined. Set to falsy to always check for the paths presence\n* @param {boolean} [options.preventLoops=true] Assume that the watcher can effect a peer expression and that we should not keep retriggering this watch expression\n*/\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  install: function install(app, options) {\n    app.mixin({\n      methods: {\n        $watchAll: function $watchAll(props, callback, options) {\n          var _arguments = arguments,\n              _this = this;\n\n          var settings = _objectSpread({\n            needAll: false,\n            needAllLock: true,\n            preventLoops: true,\n            immediate: false\n          }, options); // Remap handler based on the settings {{{\n\n\n          var handler;\n\n          if (settings.needAll) {\n            // Remap handler with extra behaviour that checks all properties first\n            var seenAll = false; // Whether at some point we have seen all values\n\n            handler = function handler() {\n              if (settings.needAllLock && seenAll) return callback.apply(_this, _arguments);\n              if (settings.preventLoops && _this.$duringWatchAll) return; // Already updating\n\n              if (settings.preventLoops) _this.$duringWatchAll = true;\n\n              if (props.some(function (p) {\n                return !_this.$hasPath(p);\n              })) {\n                // Not ready yet\n                _this.$duringWatchAll = false;\n                return;\n              } else {\n                seenAll = true;\n              }\n\n              callback.apply(_this, _arguments);\n              if (settings.preventLoops) _this.$duringWatchAll = false;\n            };\n          } else {\n            // No special treatment - just pass the callback\n            handler = callback;\n          } // }}}\n          // Attach watcher to every named prop\n\n\n          props.forEach(function (prop) {\n            return _this.$watch(prop, handler.bind(null, prop));\n          }); // Run handler immediately if needed\n\n          if (settings.immediate) handler();\n        }\n      }\n    });\n  }\n});\n\n//# sourceURL=webpack://@momsfriendlydevco/macgyver/./src/libs/watchAll.js?");

/***/ }),

/***/ "./src/vue-macgyver.js":
/*!*****************************!*\
  !*** ./src/vue-macgyver.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VueMacgyver\": () => (/* binding */ VueMacgyver)\n/* harmony export */ });\n/* harmony import */ var _macgyver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./macgyver.js */ \"./src/macgyver.js\");\n/* harmony import */ var _libs_emit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/emit.js */ \"./src/libs/emit.js\");\n/* harmony import */ var _momsfriendlydevco_vue_setpath__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @momsfriendlydevco/vue-setpath */ \"./node_modules/@momsfriendlydevco/vue-setpath/index.js\");\n/* harmony import */ var _libs_watchAll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/watchAll.js */ \"./src/libs/watchAll.js\");\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n\n\n\n\n/**\n* Main MacGyver plugin\n* This service requires {$http, $toast} to be available on the prototype\n* TODO: Bring in $http and $toast as plugin mixin?\n* @var {Object}\n*/\n// TODO: Could use pattern like VueRouter and define a VueMacgyver Class.\n//export default {\n//\tinstall: function (app, options) {\n\nvar VueMacgyver = /*#__PURE__*/function () {\n  function VueMacgyver() {\n    _classCallCheck(this, VueMacgyver);\n  }\n\n  _createClass(VueMacgyver, [{\n    key: \"install\",\n    value: function install(app, options) {\n      var $macgyver = _macgyver_js__WEBPACK_IMPORTED_MODULE_0__.default;\n      /**\n      * Axios compatible HTTP fetcher\n      * Optional binding unless anything requires web access\n      * @var {Object}\n      */\n\n      $macgyver.$http;\n      /**\n      * Doop compatible Prompt handler\n      * @var {Object}\n      */\n\n      $macgyver.$prompt;\n      /**\n      * Generic fallback action handler\n      * @var {function} Called as `(action, params...)`\n      i*/\n\n      $macgyver.$eval = function () {\n        var _console;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return (_console = console).warn.apply(_console, ['Fallback $macgyver.$eval('].concat(args, [')']));\n      }; // Absorb various methods from a Vue prototype\n\n\n      var vInstance = new app();\n      ['$on', '$off', '$once', '$emit'].forEach(function (method) {\n        return $macgyver[method] = vInstance[method].bind(vInstance);\n      }); // Auto-bind to Axios if its defined\n\n      if ($macgyver.utils.global.axios) $macgyver.$http = $macgyver.utils.global.axios;\n\n      app.mgComponent = function (name, component) {\n        if ($macgyver.widgets[name]) throw new Error(\"Cannot redeclare MacGyver component \\\"\".concat(name, \"\\\"\"));\n        if (!name.startsWith('mg')) throw new Error(\"All MacGyver components must be prefixed with \\\"mg\\\", given \\\"\".concat(name, \"\\\"\"));\n        $macgyver.widgets[name] = _objectSpread(_objectSpread({}, component), {}, {\n          meta: _objectSpread({\n            id: _.camelCase(name),\n            title: _.startCase(name),\n            icon: 'far fa-rectangle-wide',\n            category: 'Misc',\n            preferId: false,\n            shorthand: [],\n            format: true,\n            formatClass: ''\n          }, component.meta)\n        });\n\n        var vueComponent = _objectSpread({\n          inject: component.inject || ['$mgForm'],\n          // Defer to component injects or default to injecting $mgForm\n          data: function data() {\n            return _objectSpread({\n              data: undefined\n            }, component.data ? component.data() : {});\n          },\n          props: _objectSpread({\n            $type: {\n              type: String,\n              default: name\n            },\n            $dataPath: {\n              type: String\n            },\n            $specPath: {\n              type: String\n            },\n            // FIXME: Having a `change` property conflicts with event handlers called `change`.\n            change: {\n              type: Function\n            },\n            value: {}\n          }, _.mapValues(component.props || {}, function (prop) {\n            // Rewrite MacGyver props into Vue compatible props\n            var newProp = _objectSpread({}, prop.default ? {\n              default: prop.default\n            } : {}); // FIXME: This needs putting into each mgComponent declaration for Vue validation\n            // Convert prop type to Vue native instances {{{\n\n\n            if (prop.vueType) {\n              var propType = _.chain(prop.vueType).castArray() // Splat into an array (even if its a simple string)\n              .map(function (type) {\n                // Map each item into the native type\n                switch (type) {\n                  // String to type bindings (usually via vueType)\n                  case 'array':\n                    return Array;\n\n                  case 'boolean':\n                    return Boolean;\n\n                  case 'date':\n                    return Date;\n\n                  case 'number':\n                    return Number;\n\n                  case 'object':\n                    return Object;\n\n                  case 'string':\n                    return String;\n\n                  case 'any':\n                    return;\n                  // Do not append type checking\n\n                  default:\n                    console.warn(\"Unknown vueType JS primative \\\"\".concat(type, \"\\\" while declaring component \\\"\").concat(name, \"\\\" - assuming \\\"string\\\"\"));\n                    return String;\n                }\n              }).filter().thru(function (v) {\n                return v.length < 2 ? v[0] : v;\n              }) // Flatten 1 item arrays into its native type\n              .value();\n\n              if (propType) newProp.type = propType; // Only allocate type if there is one (i.e. ignore 'any' types)\n            } else {\n              switch (prop.type) {\n                case 'mgText':\n                case 'mgChoiceAutocomplete':\n                case 'mgChoiceButtons':\n                case 'mgChoiceDropdown':\n                case 'mgChoiceRadio':\n                case 'mgChoiceTree':\n                case 'mgCode':\n                case 'mgColor':\n                case 'mgEmail':\n                case 'mgIcon':\n                case 'mgPassword':\n                case 'mgRestQuery':\n                case 'mgTextArea':\n                case 'mgUnknown':\n                case 'mgUrl':\n                case 'mgWysiwyg':\n                  newProp.type = String;\n                  break;\n\n                case 'mgNumber':\n                  newProp.type = Number;\n                  break;\n\n                case 'mgChoiceCheckbox':\n                case 'mgToggle':\n                  newProp.type = Boolean;\n                  break;\n\n                case 'mgChoiceList':\n                case 'mgChoiceTags':\n                case 'mgList':\n                case 'mgTable':\n                  newProp.type = Array;\n                  break;\n\n                case 'mgQuery':\n                  newProp.type = Object;\n\n                case 'mgDate':\n                case 'mgDatetime':\n                case 'mgTime':\n                  newProp.type = Date;\n                  break;\n\n                case Number:\n                case String:\n                case Array:\n                case Object:\n                case Date:\n                  console.warn('Used native binding in component prop (e.g. `{type: Array}`). Always use mg* component types so these components are editable in the mgFormEditor');\n                  newProp.type = prop.type; // Native Vue types\n\n                  break;\n\n                case Function:\n                  console.warn('Used native binding in component prop (e.g. `{type: Function}`). Always use mg* component types so these components are editable in the mgFormEditor');\n                  newProp.type = Function;\n                  break;\n\n                default:\n                  console.warn(\"Unknown primative mapping of prop type \\\"\".concat(prop.type, \"\\\" while declaring component \\\"\").concat(name, \"\\\" - assuming \\\"String\\\"\"));\n                  newProp.type = String;\n              }\n            } // }}}\n\n\n            return newProp;\n          })),\n          methods: _objectSpread({\n            mgSetup: function mgSetup() {\n              var _this = this;\n\n              // Setup event listners {{{\n              this.$on('mgIdentify', function (reply) {\n                return reply(_this);\n              }); // }}}\n              // Read in initial data value {{{\n\n              var refresher = function refresher() {\n                // FIXME: Match empty strings also?\n                if (_this.$props.value) {\n                  // Standalone value\n                  _this.data = _.clone(_this.$props.value);\n                } else if (_this.$props.$dataPath) {\n                  // Has a data path\n                  _this.data = _.get(_this.$mgForm.formData, _this.$props.$dataPath);\n                } else if (_this.$props.default) {\n                  // Has a default\n                  _this.data = _.clone(_this.$props.default);\n                }\n              };\n\n              this.$on('mgRefresh', refresher);\n              this.$on('mgRefreshForm', refresher);\n              refresher(); // }}}\n              // Data watcher which transforms change operations into emitters to the nearest parent form {{{\n\n              this.$watch('data', function (value) {\n                // Emit `mgChange` to form element (if there is a parent form)\n                // FIXME: Skip when this.$props.value is defined?\n                if (_this.$mgForm && _this.$props.$dataPath) _this.$mgForm.$emit('mgChange', {\n                  path: _this.$props.$dataPath,\n                  value: value\n                }); // Emit regular `change` event\n\n                _this.$emit('change', value); // Is there a prop attached which monitors change?\n                // FIXME: Having a `change` property conflicts with event handlers called `change`.\n                // FIXME: Use `call` with a context?\n\n\n                if (_this.$props.change) _this.$props.change(value);\n              }, {\n                deep: true\n              }); // }}}\n            }\n          }, component.methods),\n          created: function created() {\n            this.mgSetup();\n            if (component.created) return component.created.call(this); // Call components own created() method if there is one\n          }\n        }, _.omit(component, [// Import remaining Vue properties that are not explicitly merged in above\n        'inject', 'data', 'props', 'methods', 'created']));\n\n        return app.component(name, vueComponent);\n      };\n\n      app.use(_libs_emit_js__WEBPACK_IMPORTED_MODULE_1__.default);\n      app.use(_momsfriendlydevco_vue_setpath__WEBPACK_IMPORTED_MODULE_2__.default);\n      app.use(_libs_watchAll_js__WEBPACK_IMPORTED_MODULE_3__.default);\n      app.prototype.$macgyver = $macgyver; // TODO: Vue3\n      //app.provide('macgyver', options)\n    }\n  }]);\n\n  return VueMacgyver;\n}();\n;\n\n//# sourceURL=webpack://@momsfriendlydevco/macgyver/./src/vue-macgyver.js?");

/***/ })

},
0,[["./src/vue-macgyver.js","macgyver"]]]);
});